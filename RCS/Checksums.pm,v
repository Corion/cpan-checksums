head	1.18;
access;
symbols
	v1_016:1.18
	v1_015:1.16
	v1_014:1.15
	v1_011:1.12
	v1_0:1.11
	v1_009:1.9
	v1_008:1.8
	v1_007:1.7
	v1_005:1.6
	v1_004:1.5
	v1_003:1.4
	v1_002:1.3
	v1_001:1.2;
locks
	k:1.18; strict;
comment	@# @;


1.18
date	2005.01.24.07.51.14;	author k;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.23.18.23.26;	author k;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.03.19.20.25;	author k;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.03.15.43.07;	author k;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.02.10.24.18;	author k;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.02.10.23.07;	author k;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.02.09.34.32;	author k;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.07.08.52.53;	author k;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.06.17.18.31;	author k;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.31.20.22.58;	author k;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.13.11.21.29;	author k;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.11.13.35.39;	author k;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.11.10.02.33;	author k;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.11.09.42.08;	author k;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.11.08.40.36;	author k;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.10.09.12.45;	author k;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.10.06.35.18;	author k;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.09.22.33.18;	author k;	state Exp;
branches;
next	;


desc
@@


1.18
log
@*** empty log message ***
@
text
@package CPAN::Checksums;

use strict;
use vars qw($VERSION $CAUTION $TRY_SHORTNAME
            $SIGNING_PROGRAM $SIGNING_KEY
            $MIN_MTIME_CHECKSUMS $IGNORE_MATCH
            @@ISA @@EXPORT_OK);

require Exporter;

@@ISA = qw(Exporter);
@@EXPORT_OK = qw(updatedir);
$VERSION = sprintf "%d.%03d", q$Revision: 1.17 $ =~ /(\d+)\.(\d+)/;
$CAUTION ||= 0;
$TRY_SHORTNAME ||= 0;
$SIGNING_PROGRAM ||= 'gpg --clearsign --default-key ';
$SIGNING_KEY ||= '';
$MIN_MTIME_CHECKSUMS ||= 0;
$IGNORE_MATCH = qr{(?i-xsm:readme$)};

use DirHandle ();
use IO::File ();
use Digest::MD5 ();
use Compress::Zlib ();
use File::Spec ();
use Data::Dumper ();
use Data::Compare ();

sub updatedir ($) {
  my($dirname) = @@_;
  my $dref = {};
  my(%shortnameseen,@@p);
  my($dh)= DirHandle->new;
  my($fh) = new IO::File;
  $dh->open($dirname) or die "Couldn't opendir $dirname\: $!";
 DIRENT: for my $de ($dh->read) {
    next if $de =~ /^\./;
    next if substr($de,0,9) eq "CHECKSUMS";
    next if $IGNORE_MATCH && $de =~ $IGNORE_MATCH;

    my $abs = File::Spec->catfile($dirname,$de);

    #
    # SHORTNAME offers an 8.3 name, probably not needed but it was
    # always there,,,
    #
    if ($TRY_SHORTNAME) {
      my $shortname = lc $de;
      $shortname =~ s/\.tar[._-]gz$/\.tgz/;
      my $suffix;
      ($suffix = $shortname) =~ s/.*\.//;
      substr($suffix,3) = "" if length($suffix) > 3;
      if ($shortname =~ /\-/) {
        @@p = $shortname =~ /(.{1,16})-.*?([\d\.]{2,8})/;
      } else {
        @@p = $shortname =~ /(.{1,8}).*?([\d\.]{2,8})/;
      }
      $p[0] ||= lc $de;
      $p[0] =~ s/[^a-z0-9]//g;
      $p[1] ||= 0;
      $p[1] =~ s/\D//g;
      my $counter = 7;
      while (length($p[0]) + length($p[1]) > 8) {
        substr($p[0], $counter) = "" if length($p[0]) > $counter;
        substr($p[1], $counter) = "" if length($p[1]) > $counter--;
      }
      my $dot = $suffix ? "." : "";
      $shortname = "$p[0]$p[1]$dot$suffix";
      while (exists $shortnameseen{$shortname}) {
        my($modi) = $shortname =~ /([a-z\d]+)/;
        $modi++;
        $shortname = "$modi$dot$suffix";
        if (++$counter > 1000){ # avoid endless loops and accept the buggy choice
          warn "Warning: long loop on shortname[$shortname]de[$de]";
          last;
        }
      }
      $dref->{$de}->{shortname} = $shortname;
      $shortnameseen{$shortname} = undef; # for exists check good enough
    }

    #
    # STAT facts
    #
    if (-l File::Spec->catdir($dirname,$de)){
      # Symlinks are a mess on a replicated, database driven system,
      # but as they are not forbidden, we cannot ignore them. We do
      # have a directory with nothing but a symlink in it. When we
      # ignored the symlink, we did not write a CHECKSUMS file and
      # CPAN.pm issued lots of warnings:-(
      $dref->{$de}{issymlink} = 1;
    }
    if (-d File::Spec->catdir($dirname,$de)){
      $dref->{$de}{isdir} = 1;
    } else {
      my @@stat = stat $abs or next DIRENT;
      $dref->{$de}{size} = $stat[7];
      my(@@gmtime) = gmtime $stat[9];
      $gmtime[4]++;
      $gmtime[5]+=1900;
      $dref->{$de}{mtime} = sprintf "%04d-%02d-%02d", @@gmtime[5,4,3];

      my $md5 = Digest::MD5->new;
      $fh->open("$abs\0") or die "Couldn't open $abs: $!";
      $md5->addfile($fh);
      $fh->close;
      my $digest = $md5->hexdigest;
      $dref->{$de}{md5} = $digest;
      $md5 = Digest::MD5->new;
      if ($de =~ /\.gz$/) {
        my($buffer, $gz);
        if ($gz  = Compress::Zlib::gzopen($abs, "rb")) {
          $md5->add($buffer)
              while $gz->gzread($buffer) > 0;
          # Error management?
          $dref->{$de}{'md5-ungz'} = $md5->hexdigest;
          $gz->gzclose;
        }
      }
    } # ! -d
  }
  $dh->close;
  my $ckfn = File::Spec->catfile($dirname, "CHECKSUMS"); # checksum-file-name
  unless (%$dref) { # no files to checksum
    unlink $ckfn or die "Couldn't unlink $ckfn: $!" if -f $ckfn;
    return 1;
  }
  local $Data::Dumper::Indent = 1;
  local $Data::Dumper::Quotekeys = 1;
  my $ddump = Data::Dumper->new([$dref],["cksum"])->Dump;
  my $is_signed = 0;
  my @@ckfnstat = stat $ckfn;
  if ($fh->open($ckfn)) {
    my $cksum = "";
    local $/ = "\n";
    while (<$fh>) {
      next if /^\#/;
      $is_signed = 1 if /SIGNED MESSAGE/;
      $cksum .= $_;
    }
    close $fh;
    if ( !!$SIGNING_KEY == !!$is_signed ) { # either both or neither
      if (!$MIN_MTIME_CHECKSUMS || $ckfnstat[9] > $MIN_MTIME_CHECKSUMS ) {
        # recent enough
        return 1 if $cksum eq $ddump;
        return 1 if ckcmp($cksum,$dref);
      }
    }
    if ($CAUTION) {
      my $report = investigate($cksum,$dref);
      warn $report if $report;
    }
  }
  chmod 0644, $ckfn or die "Couldn't chmod to 0644 for $ckfn\: $!" if -f $ckfn;
  open $fh, ">$ckfn\0" or die "Couldn't open >$ckfn\: $!";

  local $\;
  if ($SIGNING_KEY) {
    print $fh "0&&<<''; # this PGP-signed message is also valid perl\n";
    close $fh;
    open $fh, "| $SIGNING_PROGRAM $SIGNING_KEY >> $ckfn" or die "Could not call gpg: $!";
    $ddump .= "__END__\n";
  }

  my $message = sprintf "# CHECKSUMS file written on %s by CPAN::Checksums (v%s)\n%s",
      scalar gmtime, $VERSION, $ddump;
  print $fh $message;
  my $success = close $fh;
  if ($SIGNING_KEY && !$success) {
    warn "Couldn't run '$SIGNING_PROGRAM $SIGNING_KEY'!
Writing to $ckfn directly";
    open $fh, ">$ckfn\0" or die "Couldn't open >$ckfn\: $!";
    print $fh $message;
    close $fh or warn "Couldn't close $ckfn: $!";
  }
  chmod 0444, $ckfn or die "Couldn't chmod to 0444 for $ckfn\: $!";
  return 2;
}

sub ckcmp ($$) {
  my($old,$new) = @@_;
  for ($old,$new) {
    $_ = makehashref($_);
  }
  Data::Compare::Compare($old,$new);
}

# see if a file changed but the name not
sub investigate ($$) {
  my($old,$new) = @@_;
  for ($old,$new) {
    $_ = makehashref($_);
  }
  my $complain = "";
  for my $dist (sort keys %$new) {
    if (exists $old->{$dist}) {
      my $headersaid;
      for my $diff (qw/md5 size md5-ungz mtime/) {
        next unless exists $old->{$dist}{$diff} &&
            exists $new->{$dist}{$diff};
        next if $old->{$dist}{$diff} eq $new->{$dist}{$diff};
        $complain .=
            scalar localtime().
                ":\ndiffering old/new version of same file $dist:\n"
                    unless $headersaid++;
        $complain .=
            qq{\t$diff "$old->{$dist}{$diff}" -> "$new->{$dist}{$diff}"\n}; #};
      }
    }
  }
  $complain;
}

sub makehashref ($) {
  local($_) = shift;
  unless (ref $_ eq "HASH") {
    require Safe;
    my($comp) = Safe->new("CPAN::Checksums::reval");
    my $cksum; # used by Data::Dumper
    $_ = $comp->reval($_) || {};
    die "Caught $@@" if $@@;
  }
  $_;
}

1;

__END__

=head1 NAME

CPAN::Checksums - Write a CHECKSUMS file for a directory as on CPAN

=head1 SYNOPSIS

  use CPAN::Checksums qw(updatedir);
  my $success = updatedir($directory);

=head1 INCOMPATIBILITY ALERT

Since version 1.0 the generation of the attribute C<shortname> is
turned off by default. It was too slow and was not used as far as I
know, and above all, it could fail on large directories. The shortname
feature can still be turned on by setting the global variable
$TRY_SHORTNAME to a true value.

=head1 DESCRIPTION

updatedir takes a directory name as argument and writes a typical
CHECKSUMS file in that directory as used on CPAN unless a previously
written CHECKSUMS file is there that is still valid. Returns 2 if a
new CHECKSUMS file has been written, 1 if a valid CHECKSUMS file is
already there, otherwise dies.

=head2 Global Variables in package CPAN::Checksums

=over

=item $IGNORE_MATCH

If the global variable $IGNORE_MATCH is set, the all files matching
this expression will be completely ignored and will not be included in
the CPAN CHECKSUMS files. Per default this variable is set to

    qr{(?i-xsm:readme$)}

=item $CAUTION

Setting the global variable $CAUTION causes updatedir() to report
changes of files in the attributes C<size>, C<mtime>, C<md5>, or
C<md5-ungz> to STDERR.

=item $TRY_SHORTNAME

By setting the global variable $TRY_SHORTNAME to a true value, you can
tell updatedir() to include an attribute C<shortname> in the resulting
hash that is 8.3-compatible. Please note, that updatedir() in this
case may be slow and may even fail on large directories, because it
will always only try 1000 iterations to find a name that is not yet
taken and then give up.

=item $SIGNING_KEY

Setting the global variable $SIGNING_KEY makes the generated CHECKSUMS
file to be clear-signed by the command specified in $SIGNING_PROGRAM
(defaults to C<gpg --clearsign --default-key >), passing the signing
key as an extra argument.  The resulting CHECKSUMS file should look like:

    0&&<<''; # this PGP-signed message is also valid perl
    -----BEGIN PGP SIGNED MESSAGE-----
    Hash: SHA1

    # CHECKSUMS file written on ... by CPAN::Checksums (v...)
    $cksum = {
	...
    };

    __END__
    -----BEGIN PGP SIGNATURE-----
    ...
    -----END PGP SIGNATURE-----

note that the actual data remains intact, but two extra lines are
added to make it legal for both OpenPGP and perl syntax.

=item $MIN_MTIME_CHECKSUMS

If the global variable $MIN_MTIME_CHECKSUMS is set, then updatedir
will renew signatures on checksum files that have an older mtime than
the given value.

=back

=head1 PREREQUISITES

DirHandle, IO::File, Digest::MD5, Compress::Zlib, File::Spec,
Data::Dumper, Data::Compare

=head1 AUTHOR

Andreas Koenig, andreas.koenig@@anima.de; GnuPG support by Autrijus Tang

=head1 SEE ALSO

perl(1).

=cut
@


1.17
log
@*** empty log message ***
@
text
@d13 1
a13 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.16 $ =~ /(\d+)\.(\d+)/;
d220 1
a220 1
    $_ = $comp->reval($_);
@


1.16
log
@*** empty log message ***
@
text
@d6 1
d13 1
a13 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.15 $ =~ /(\d+)\.(\d+)/;
d18 2
d39 1
a39 1
    next if $de =~ /readme$/i;
d123 2
a124 2
  my $ckfn = File::Spec->catfile($dirname, "CHECKSUMS");
  unless (%$dref) {
d132 1
d143 5
a147 2
      return 1 if $cksum eq $ddump;
      return 1 if ckcmp($cksum,$dref);
d253 15
a267 2
already there, otherwise dies. Please note, that CPAN CHECKSUMS files
ignore filenames matching C</readme$/i>.
d273 2
d282 2
d306 8
@


1.15
log
@*** empty log message ***
@
text
@d12 1
a12 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.14 $ =~ /(\d+)\.(\d+)/;
d158 1
a158 1
  printf $fh "# CHECKSUMS file written on %s by CPAN::Checksums (v%s)\n%s",
d160 1
d164 4
a167 5
Falling back to ordinary append mode.";
    open $fh, ">>$ckfn\0" or die "Couldn't open >>$ckfn\: $!";
    printf $fh "# CHECKSUMS file written on %s by CPAN::Checksums (v%s)\n%s",
        scalar gmtime, $VERSION, $ddump;
    close $fh or warn "Couldn't close $ckfn in append mode: $!";
@


1.14
log
@-- revert last change
@
text
@d12 1
a12 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.13 $ =~ /(\d+)\.(\d+)/;
d138 1
a138 1
    if ( !$SIGNING_KEY ^ !!$is_signed ) { # either both or neither
d160 9
a168 1
  close $fh;
d170 1
a170 1
  2;
@


1.13
log
@-- cosmetic change: print comment before signed part
@
text
@d12 1
a12 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.12 $ =~ /(\d+)\.(\d+)/;
a149 3
  printf $fh "# CHECKSUMS file written on %s by CPAN::Checksums (v%s)\n",
      scalar gmtime, $VERSION;

d158 2
a159 1
  print $fh $ddump;
@


1.12
log
@-- SIGNING stuff from Autrijus
@
text
@d12 1
a12 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.11 $ =~ /(\d+)\.(\d+)/;
d150 3
d161 1
a161 2
  printf $fh "# CHECKSUMS file written on %s by CPAN::Checksums (v%s)\n%s",
      scalar gmtime, $VERSION, $ddump;
@


1.11
log
@*** empty log message ***
@
text
@d4 3
a6 1
use vars qw($VERSION $CAUTION $TRY_SHORTNAME @@ISA @@EXPORT_OK);
d12 1
a12 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.10 $ =~ /(\d+)\.(\d+)/;
d15 2
d86 1
a86 1
      # ignored the symlink, we did not write a CHEKSUMS file and
d128 1
d134 1
d138 4
a141 2
    return 1 if $cksum eq $ddump;
    return 1 if ckcmp($cksum,$dref);
d149 9
d252 22
d281 1
a281 1
Andreas Koenig, andreas.koenig@@anima.de
@


1.10
log
@*** empty log message ***
@
text
@d4 1
a4 1
use vars qw($VERSION $REVISION $CAUTION $TRY_SHORTNAME @@ISA @@EXPORT_OK);
d10 1
a10 2
$REVISION = sprintf "%d.%03d", q$Revision: 1.9 $ =~ /(\d+)\.(\d+)/;
$VERSION = "1.0";
d217 6
a222 4
updatedir takes a directory name as argument and writes a CHECKSUMS
file in that directory unless a previously written CHECKSUMS file is
there that is still valid. Returns 2 if a new CHECKSUMS file has been
written, 1 if a valid CHECKSUMS file is already there, otherwise dies.
@


1.9
log
@- Add PREREQUISITES
@
text
@d4 1
a4 1
use vars qw($VERSION $CAUTION @@ISA @@EXPORT_OK);
d10 2
a11 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.8 $ =~ /(\d+)\.(\d+)/;
d13 1
a35 1
    next if -l $abs;
d41 30
a70 28
    my $shortname = lc $de;
    $shortname =~ s/\.tar[._-]gz$/\.tgz/;
    my $suffix;
    ($suffix = $shortname) =~ s/.*\.//;
    substr($suffix,3) = "" if length($suffix) > 3;
    if ($shortname =~ /\-/) {
      @@p = $shortname =~ /(.{1,16})-.*?([\d\.]{2,8})/;
    } else {
      @@p = $shortname =~ /(.{1,8}).*?([\d\.]{2,8})/;
    }
    $p[0] ||= lc $de;
    $p[0] =~ s/[^a-z0-9]//g;
    $p[1] ||= 0;
    $p[1] =~ s/\D//g;
    my $counter = 7;
    while (length($p[0]) + length($p[1]) > 8) {
      substr($p[0], $counter) = "" if length($p[0]) > $counter;
      substr($p[1], $counter) = "" if length($p[1]) > $counter--;
    }
    my $dot = $suffix ? "." : "";
    $shortname = "$p[0]$p[1]$dot$suffix";
    while (exists $shortnameseen{$shortname}) {
      my($modi) = $shortname =~ /([a-z\d]+)/;
      $modi++;
      $shortname = "$modi$dot$suffix";
      if ($counter++ > 1000){ # avoid endless loops and accept the buggy choice
        warn "Warning: long loop on shortname[$shortname]de[$de]";
        last;
d72 2
a74 2
    $dref->{$de}->{shortname} = $shortname;
    $shortnameseen{$shortname} = undef; # for exists check good enough
d79 8
d196 1
d208 8
d223 1
a223 1
Setting the global variable $CAUTION causes updatedir to report
d226 7
@


1.8
log
@*** empty log message ***
@
text
@d10 1
a10 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.7 $ =~ /(\d+)\.(\d+)/;
a185 1
# Below is the stub of documentation for your module. You better edit it!
d206 5
@


1.7
log
@*** empty log message ***
@
text
@d10 1
a10 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.6 $ =~ /(\d+)\.(\d+)/;
d109 1
a109 1
    return;
@


1.6
log
@*** empty log message ***
@
text
@d10 1
a10 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.5 $ =~ /(\d+)\.(\d+)/;
d107 4
@


1.5
log
@*** empty log message ***
@
text
@d4 1
a4 1
use vars qw($VERSION $CAUTION $VERBOSE @@ISA @@EXPORT_OK);
d10 1
a10 2
$VERSION = sprintf "%d.%03d", q$Revision: 1.4 $ =~ /(\d+)\.(\d+)/;
$VERBOSE ||= 0;
a119 6
    if ($VERBOSE) {
      require Algorithm::Diff;
      for my $d (Algorithm::Diff::diff([split /\n/, $cksum],[split /\n/, $ddump])) {
        print Data::Dumper::Dumper($d);
      }
    }
d200 1
a200 6
Setting the global variable $VERBOSE increases verbosity in that it
reports differences between old and new directory. The format of the
output needs much more work and doesn't seem very useful at the
moment.

Setting the global variabel $CAUTION causes updatedir to report
d202 1
a202 1
C<md5-ungz>.
@


1.4
log
@Skip symlinks.
@
text
@d4 1
a4 1
use vars qw($VERSION $VERBOSE @@ISA @@EXPORT_OK);
d10 3
a12 2
$VERSION = sprintf "%d.%03d", q$Revision: 1.3 $ =~ /(\d+)\.(\d+)/;
$VERBOSE = 0;
d127 4
a142 1
  my $diff = "";
d144 26
a169 6
    unless (ref $_ eq "HASH") {
      require Safe;
      my($comp) = Safe->new("CPAN::Checksums::reval");
      my $cksum; # used by Data::Dumper
      $_ = $comp->reval($_);
      die "Caught $@@" if $@@;
d172 13
a184 1
  Data::Compare::Compare($old,$new);
d206 9
@


1.3
log
@*** empty log message ***
@
text
@d10 1
a10 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.2 $ =~ /(\d+)\.(\d+)/;
d33 3
a78 1
      my $abs = File::Spec->catfile($dirname,$de);
@


1.2
log
@*** empty log message ***
@
text
@d10 1
a10 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.1 $ =~ /(\d+)\.(\d+)/;
d13 7
a19 6
use DirHandle;
use IO::File;
use Digest::MD5;
use Compress::Zlib;
use File::Spec;
use Data::Dumper;
d117 1
d132 15
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK);
a8 3
# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.
d10 121
a130 1
$VERSION = sprintf "%d.%03d", q$Revision: 1.55 $ =~ /(\d+)\.(\d+)/;
d148 3
a150 2
file in that directory. An old CHECKSUMS file is only overwritten when
it is outdated in relevant parts.
@
